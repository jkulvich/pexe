{"version":3,"sources":["webpack://Pexe/webpack/bootstrap","webpack://Pexe/./node_modules/@babel/runtime/helpers/defineProperty.js","webpack://Pexe/./node_modules/@babel/runtime/helpers/classCallCheck.js","webpack://Pexe/./node_modules/@babel/runtime/helpers/getPrototypeOf.js","webpack://Pexe/./node_modules/@babel/runtime/helpers/createClass.js","webpack://Pexe/./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","webpack://Pexe/./node_modules/@babel/runtime/helpers/inherits.js","webpack://Pexe/./node_modules/@babel/runtime/helpers/assertThisInitialized.js","webpack://Pexe/./node_modules/@babel/runtime/helpers/typeof.js","webpack://Pexe/./node_modules/@babel/runtime/helpers/wrapNativeSuper.js","webpack://Pexe/./node_modules/@babel/runtime/helpers/toConsumableArray.js","webpack://Pexe/./node_modules/@babel/runtime/helpers/setPrototypeOf.js","webpack://Pexe/./node_modules/@babel/runtime/regenerator/index.js","webpack://Pexe/./node_modules/@babel/runtime/helpers/asyncToGenerator.js","webpack://Pexe/./node_modules/@babel/runtime/node_modules/regenerator-runtime/runtime.js","webpack://Pexe/./node_modules/@babel/runtime/helpers/isNativeFunction.js","webpack://Pexe/./node_modules/@babel/runtime/helpers/construct.js","webpack://Pexe/./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","webpack://Pexe/./node_modules/@babel/runtime/helpers/iterableToArray.js","webpack://Pexe/./node_modules/@babel/runtime/helpers/nonIterableSpread.js","webpack://Pexe/./src/libs/FileReader/errors.js","webpack://Pexe/./src/libs/Bytes/errors.js","webpack://Pexe/./src/libs/Bytes/index.js","webpack://Pexe/./src/libs/FileReader/index.js","webpack://Pexe/./src/libs/BlockReader/errors.js","webpack://Pexe/./src/libs/BlockReader/index.js","webpack://Pexe/./src/libs/DataDictionary/index.js","webpack://Pexe/./src/libs/types.js","webpack://Pexe/./src/libs/ExeFile/dosHeader.js","webpack://Pexe/./src/libs/ExeFile/fileHeader.js","webpack://Pexe/./src/libs/ExeFile/dataDirectory.js","webpack://Pexe/./src/libs/ExeFile/optionalHeader.js","webpack://Pexe/./src/libs/ExeFile/ntHeader.js","webpack://Pexe/./src/libs/ExeFile/sectionHeader.js","webpack://Pexe/./src/libs/ExeFile/importDescriptor.js","webpack://Pexe/./src/libs/ExeFile/exportDescriptor.js","webpack://Pexe/./src/main.js"],"names":["FileReaderError","Error","FileReaderEOFError","BytesError","BytesNotByteError","BytesNotHexByteError","BytesNotHexStringError","BytesNotPosIntError","Bytes","byte","Number","hex","String","length","test","hexs","hexArr","match","isHex","Errors","num","Math","abs","isByte","toString","toUpperCase","padStart","parseInt","arr","align","zeros","repeat","max","Array","slice","reverse","forEach","i","byteToHex","join","isHexString","hexNums","map","hexToByte","n","pop","push","Uint8Array","pos","reduce","acc","isPosInt","str","TextEncoder","encode","TextDecoder","decode","arrayToHex","numberToArray","arrayToNumber","hexToArray","FileReader","bytes","setFile","pointer","isEOF","count","canRead","readNext","name","desc","offset","block","readArray","types","size","type","raw","text","arrayToString","BlockReaderError","BlockReaderEmptyFileReaderError","Byte","Word","DWord","BlockReader","fileReader","setReader","_reader","_pointerStack","struct","blocks","s","readBlock","char","fromCharCode","b","DataDictionary","id","machines","magics","maj","min","version","versions","subsystems","chars","charsList","code","dllchars","dllcharsList","sections","names","section","nonzero","Name","c","Type","element","QWord","BlockReaderDosHeader","structdef","_desc","readStructure","convertStructureToMap","BlockReaderFileHeader","BlockReaderDataDirectory","read","BlockReaderOptionalHeader","brDataDirectories","DataDirectory","readAll","BlockReaderNTHeader","brFileHeader","brOptionalHeader","file","optional","BlockReaderSectionHeader","BlockReaderImportDescriptor","OriginalFirstThunk","BlockReaderExportDescriptor","Pexe","breader","url","window","fetch","resp","arrayBuffer","buff","alignment","alignUp","a","ceil","rva","start","VirtualAddress","end","VirtualSize","PointerToRawData","exe","meta","isDOS","headers","dos","e_magic","isNT","nt","Signature","machine","decodeMachine","Machine","magic","decodeMagic","Magic","subsystem","decodeSubsystem","Subsystem","decodeChars","Characteristics","dllChars","decodeDllChars","DllCharacteristics","decodeSectionsName","osVersion","decodeOSVersion","MajorOperatingSystemVersion","MinorOperatingSystemVersion","dateStamp","Date","TimeDataStamp","isDLL","includes","is64","brDOSReader","getReader","brNTHeader","brSection","brImportDesc","brExportDesc","getFileBytes","directories","readDOSHeader","setPointer","e_lfanew","readNTHeader","readSections","NumberOfSections","rvaToRaw","generateRvaToRawFunc","SectionAlignment","rawImportDir","readDirImportDescriptors","rawExportDir","readDirExportDescriptors","getMeta"],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;;AAEA,iC;;;;;;ACfA;AACA;AACA;AACA;AACA;;AAEA,iC;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;;AAEA,iC;;;;;;ACPA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,8B;;;;;;AChBA,cAAc,mBAAO,CAAC,CAAmB;;AAEzC,4BAA4B,mBAAO,CAAC,CAAyB;;AAE7D;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4C;;;;;;ACZA,qBAAqB,mBAAO,CAAC,EAAkB;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,2B;;;;;;ACjBA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wC;;;;;;ACRA,wBAAwB,2EAA2E,oCAAoC,mBAAmB,GAAG,EAAE,OAAO,oCAAoC,8HAA8H,GAAG,EAAE,sBAAsB;;AAEnW;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yB;;;;;;AChBA,qBAAqB,mBAAO,CAAC,CAAkB;;AAE/C,qBAAqB,mBAAO,CAAC,EAAkB;;AAE/C,uBAAuB,mBAAO,CAAC,EAAoB;;AAEnD,gBAAgB,mBAAO,CAAC,EAAa;;AAErC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA,kC;;;;;;AC1CA,wBAAwB,mBAAO,CAAC,EAAqB;;AAErD,sBAAsB,mBAAO,CAAC,EAAmB;;AAEjD,wBAAwB,mBAAO,CAAC,EAAqB;;AAErD;AACA;AACA;;AAEA,oC;;;;;;ACVA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iC;;;;;;ACTA,iBAAiB,mBAAO,CAAC,EAAqB;;;;;;;ACA9C;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,mC;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;;AAEA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,kBAAkB;AACnD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA,EAAE,KAA0B,oBAAoB,SAAE;AAClD;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrtBA;AACA;AACA;;AAEA,mC;;;;;;ACJA,qBAAqB,mBAAO,CAAC,EAAkB;;AAE/C;AACA;AACA;AACA;;AAEA;AACA,2EAA2E;AAC3E;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4B;;;;;;AChCA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;;AAEA;AACA;AACA;;AAEA,oC;;;;;;ACVA;AACA;AACA;;AAEA,kC;;;;;;ACJA;AACA;AACA;;AAEA,oC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJA;AACO,IAAMA,sBAAb;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA,6EACS,iBADT;;AAAA;AAAA;;AAAA;AAAA,4BAAqCC,KAArC;AAIA;;AACO,IAAMC,yBAAb;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;A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","file":"pexe.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 19);\n","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","var _typeof = require(\"../helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","var getPrototypeOf = require(\"./getPrototypeOf\");\n\nvar setPrototypeOf = require(\"./setPrototypeOf\");\n\nvar isNativeFunction = require(\"./isNativeFunction\");\n\nvar construct = require(\"./construct\");\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nmodule.exports = _wrapNativeSuper;","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","module.exports = require(\"regenerator-runtime\");\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nmodule.exports = _isNativeFunction;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    module.exports = _construct = Reflect.construct;\n  } else {\n    module.exports = _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nmodule.exports = _construct;","function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;","function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;","/** Base error */\nexport class FileReaderError extends Error {\n  name = 'FileReaderError'\n}\n\n/** If end of file and can't read next */\nexport class FileReaderEOFError extends FileReaderError {\n  name = 'FileReaderEOFError'\n}\n","/** Base error */\nexport class BytesError extends Error {\n  name = 'BytesError'\n}\n\n/** If present number isn't byte */\nexport class BytesNotByteError extends BytesError {\n  name = 'BytesNotByteError'\n}\n\n/** If present string isn't one hex byte (2 chars) */\nexport class BytesNotHexByteError extends BytesError {\n  name = 'BytesNotHexByteError'\n}\n\n/** If present array isn't array of hex numbers */\nexport class BytesNotHexStringError extends BytesError {\n  name = 'BytesNotHexStringError'\n}\n\n/** If present number isn't positive integer */\nexport class BytesNotPosIntError extends BytesError {\n  name = 'BytesNotPosIntError'\n}\n","// @flow\n/*\nBytes manipulation\n*/\n\nimport * as Errors from './errors'\n\nexport default class Bytes {\n  /** Determines that number is byte */\n  static isByte (byte: number): boolean {\n    return typeof byte === typeof Number() && byte >= 0 && byte <= 255\n  }\n\n  /** Determines that string is hex byte (2 chars) */\n  static isHex (hex: string): boolean {\n    if (typeof hex !== typeof String()) return false\n    if (hex.length !== 2) return false\n    return (/[0-9a-f]{2}/i).test(hex)\n  }\n\n  /** Determines that string is hex array */\n  static isHexString (hexs: string): boolean {\n    if (typeof hexs !== typeof String()) return false\n    if (hexs.length % 2 !== 0) return false\n    let hexArr = hexs.match(/([a-z0-9]{2})/ig)\n    if (hexArr != null) {\n      for (let hex of hexArr) {\n        if (!Bytes.isHex(hex)) return false\n      }\n      return true\n    } else throw new Errors.BytesError('unexpected null after regexp')\n  }\n\n  /** Determines that number is integer and positive */\n  static isPosInt (num: number): boolean {\n    return Math.abs(num | 0) === num\n  }\n\n  /**\n   * Returns 2 chars hex string equals given byte\n   * @param {number} byte\n   * @returns {string}\n   */\n  static byteToHex (byte: number): string {\n    if (!Bytes.isByte(byte)) {\n      throw new Errors.BytesNotByteError(`expected number byte, got: ${byte}`)\n    }\n    return byte.toString(16).toUpperCase().padStart(2, '0')\n  }\n\n  /**\n   * Returns byte by given hex string\n   * @param {string} hex - 2 chars\n   * @returns {number}\n   */\n  static hexToByte (hex: string): number {\n    if (!Bytes.isHex(hex)) {\n      throw new Errors.BytesNotHexByteError(`expected string hex with 1 or 2 hex chars, got: ${hex}`)\n    }\n    return parseInt(hex, 16)\n  }\n\n  /**\n   * Returns hex string equals given bytes array\n   * @param arr {number[]}\n   * @param align {number} - left zero bytes count alignment\n   * @returns {string}\n   */\n  static arrayToHex (arr: Uint8Array, align: number = 0): string {\n    let zeros = '00'.repeat(Math.max(0, align - arr.length))\n    let hexs = Array(arr.length)\n    arr.slice().reverse().forEach((num, i) => {\n      hexs[i] = Bytes.byteToHex(num)\n    })\n    return zeros + hexs.join('')\n  }\n\n  /**\n   * Returns bytes array by given hex string\n   * @param hexs {string}\n   * @returns {number[]}\n   */\n  static hexToArray (hexs: string): Uint8Array {\n    if (!Bytes.isHexString(hexs)) throw new Errors.BytesNotHexStringError(`expected hex string, got: ${hexs}`)\n    let hexNums = hexs.match(/[a-z\\d]{2}/gi)\n    if (hexNums == null) throw new Errors.BytesError('unexpected null after regexp')\n    let arr = hexNums.map(hex => Bytes.hexToByte(hex)).reverse()\n    while (arr.length > 0) {\n      let n = arr.pop()\n      if (n !== 0) {\n        arr.push(n)\n        break\n      }\n    }\n    return new Uint8Array(arr)\n  }\n\n  /**\n   * Returns number by given bytes array\n   * @param arr {number[]}\n   * @returns {number}\n   */\n  static arrayToNumber (arr: Uint8Array): number {\n    return [...arr].map((num, pos) => (256 ** pos) * num).reduce((acc: number, num) => acc + num)\n  }\n\n  /**\n   * Returns bytes array by given number\n   * @param num {number}\n   * @returns {number[]}\n   */\n  static numberToArray (num: number): Uint8Array {\n    if (!Bytes.isPosInt(num)) throw new Errors.BytesNotPosIntError(`expected positive integer, got: ${num}`)\n    let arr = []\n    while (num > 0) {\n      arr.push(num % 256)\n      num = (num - num % 256) / 256\n    }\n    return new Uint8Array(arr)\n  }\n\n  /**\n   * Returns bytes array by given text\n   * @param str {string}\n   * @returns {Array}\n   */\n  static stringToArray (str: string): Uint8Array {\n    return new TextEncoder().encode(str)\n  }\n\n  /**\n   * Returns text by given bytes array\n   * @param arr {number[]}\n   * @returns {string}\n   */\n  static arrayToString (arr: Uint8Array): string {\n    return new TextDecoder().decode(arr)\n  }\n\n  /**\n   * Returns hex string by given number\n   * @param num {number}\n   * @param align {number}\n   * @returns {string}\n   */\n  static numberToHex (num: number, align: number = 0): string {\n    return Bytes.arrayToHex(Bytes.numberToArray(num), align)\n  }\n\n  /**\n   * Returns number by given hex string\n   * @param hex {string}\n   * @returns {number}\n   */\n  static hexToNumber (hex: string): number {\n    return Bytes.arrayToNumber(Bytes.hexToArray(hex))\n  }\n}\n","// @flow\n/*\nReads file by byte per byte\n*/\n\nimport * as Errors from './errors'\nimport Bytes from '../Bytes'\n\n/** Information block scheme */\nexport type DataBlock = {\n  size: number,\n  name: string,\n  desc: string,\n  offset: number,\n  type: string,\n  raw: Uint8Array,\n  num: number,\n  text: string,\n  hex: string,\n}\n\n/** Reading and parsing byte array */\nexport default class FileReader {\n  bytes: Uint8Array\n  pointer: number = 0\n\n  constructor (bytes?: Uint8Array) {\n    if (bytes) this.setFile(bytes)\n  }\n\n  /** Set new working file */\n  setFile (bytes: Uint8Array): void {\n    this.bytes = bytes\n    this.pointer = 0\n  }\n\n  /** Is pointer in end of file */\n  isEOF (): boolean {\n    return this.pointer >= this.bytes.length - 1\n  }\n\n  /** Read next byte or throw exception */\n  readNext (): number {\n    if (!this.isEOF()) return this.bytes[this.pointer++]\n    else throw new Errors.FileReaderEOFError(`end of file`)\n  }\n\n  /** Determines that can read given count of bytes **/\n  canRead (count: number): boolean {\n    return this.pointer + count <= this.bytes.length\n  }\n\n  /** Reads given count of bytes or throws exception **/\n  readArray (count: number): Uint8Array {\n    if (this.canRead(count)) return new Uint8Array(count).map(() => this.readNext())\n    else throw new Errors.FileReaderEOFError(`end of file`)\n  }\n\n  /** Reads block and makes block with description */\n  readBlock (count: number, name: string = '', desc: string = ''): DataBlock {\n    let offset = this.pointer\n    let block = this.readArray(count)\n    let types: { [number]: string } = {}\n    types[1] = 'Byte'\n    types[2] = 'Word'\n    types[4] = 'DWord'\n    types[8] = 'QWord'\n    types[16] = 'YWord'\n    return {\n      size: count,\n      name,\n      desc,\n      offset: offset,\n      type: types[count] || 'Data',\n      raw: block,\n      num: Bytes.arrayToNumber(block),\n      text: Bytes.arrayToString(block),\n      hex: Bytes.arrayToHex(block)\n    }\n  }\n}\n","/** Base error */\nexport class BlockReaderError extends Error {\n  name = 'BlockReaderError'\n}\n\n/** If FileReader is not set */\nexport class BlockReaderEmptyFileReaderError extends BlockReaderError {\n  name = 'BlockReaderEmptyFileReaderError'\n}\n","// @flow\n/*\n  Представляет методы для чтения блоков информации\n */\n\nimport FileReader from '../FileReader'\nimport * as Errors from './errors'\n\nimport type { DataBlock } from '../FileReader'\nimport type { DosHeader } from '../ExeFile/dosHeader'\nimport type { FileHeader } from '../ExeFile/fileHeader'\nimport type { OptionalHeader } from '../ExeFile/optionalHeader'\nimport type { NtHeader } from '../ExeFile/ntHeader'\nimport type { DataDirectory } from '../ExeFile/dataDirectory'\nimport type { SectionHeader } from '../ExeFile/sectionHeader'\nimport type { ExportDescriptor } from '../ExeFile/exportDescriptor'\nimport type { ImportDescriptor } from '../ExeFile/importDescriptor'\nimport { BlockReaderError } from './errors'\n\nconst Byte = 1\nconst Word = 2\nconst DWord = 4\n\n/** Описание блока информации ля извлечения */\nexport type DataBlockDesk = {\n  size: number,\n  name: string,\n  desc: string\n}\n\n/** Читает блоки информации из файла */\nexport default class BlockReader {\n  _reader: FileReader\n  _pointerStack: Array<number> = []\n\n  constructor (fileReader?: FileReader) {\n    if (fileReader) {\n      this.setReader(fileReader)\n    }\n  }\n\n  /** Устанавливает инструмент чтения файла */\n  setReader (fileReader: FileReader) {\n    this._reader = fileReader\n  }\n\n  /** Возвращает инструмент чтения файла */\n  getReader (): FileReader {\n    return this._reader\n  }\n\n  /** Возвращает байты файла */\n  getFileBytes (): Uint8Array {\n    return this._reader.bytes\n  }\n\n  /** Устанавливает позицию курсора в файле [//TODO: DEPRECATED, удалить this]*/\n  setPointer (pos: number): BlockReader {\n    if (!this._reader) throw new Errors.BlockReaderEmptyFileReaderError(`file reader is not set`)\n    this._reader.pointer = pos\n    return this\n  }\n\n  /** Возвращает позицию указателя */\n  getPointer (): number {\n    return this._reader.pointer\n  }\n\n  /** Сохраняет позицию курсора в стек */\n  savePointer () {\n    this._pointerStack.push(this._reader.pointer)\n  }\n\n  /** Восстанавливает позицию курсора из стека */\n  restorePointer () {\n    if (this._pointerStack.length > 0)\n      this._reader.pointer = this._pointerStack.pop()\n    else throw new BlockReaderError('pointer stack is empty, save pointer first')\n  }\n\n  /** Читает массив блоков информации по массиву их описаний */\n  readStructure (struct: Array<DataBlockDesk>): Array<DataBlock> {\n    if (!this._reader) throw new Errors.BlockReaderEmptyFileReaderError(`file reader is not set`)\n    let blocks: Array<DataBlock> = []\n    struct.forEach(s => blocks.push(this._reader.readBlock(s.size, s.name, s.desc)))\n    return blocks\n  }\n\n  /** Читает строку оканчивающуюся нулевым символом */\n  readString (): string {\n    let name = []\n    for (; ;) {\n      let char = this._reader.readNext()\n      if (char === 0) break\n      name.push(char)\n    }\n    return String.fromCharCode(...name)\n  }\n\n  /**\n   * Конвертирует массив блоков информации в словарь по их именам\n   * @param block\n   * @returns {Object}\n   */\n  convertStructureToMap (block: Array<DataBlock>): { [string]: DataBlock } {\n    let map: { [string]: DataBlock } = {}\n    block.forEach(b => {\n      map[b.name] = b\n    })\n    return map\n  }\n\n  /** Создаёт новый блок описания блока информации */\n  _desc (size: number, name: string, desc: string = ''): DataBlockDesk {\n    return { size, name, desc }\n  }\n}\n","// @flow\n/*\nCode to text decoder\n*/\n\nimport type { SectionHeader } from '../ExeFile/sectionHeader'\n\nexport default class DataDictionary {\n  /** Decode architecture [Machine] */\n  static decodeMachine (id: number): string {\n    let machines = {\n      [String(0x0000)]: 'Unknown',\n      [String(0x014C)]: 'I386',\n      [String(0x014D)]: 'I486',\n      [String(0x014E)]: 'PENTIUM',\n      [String(0x0160)]: 'R3000_BE',\n      [String(0x0162)]: 'R3000',\n      [String(0x0166)]: 'R4000',\n      [String(0x0168)]: 'R10000',\n      [String(0x0169)]: 'WCEMIPSV2',\n      [String(0x0184)]: 'ALPHA',\n      [String(0x01A2)]: 'SH3',\n      [String(0x01A3)]: 'SH3DSP',\n      [String(0x01A6)]: 'SH4',\n      [String(0x01A8)]: 'SH5',\n      [String(0x01C0)]: 'ARM',\n      [String(0x01C2)]: 'THUMB',\n      [String(0x01D3)]: 'AM33',\n      [String(0x01F0)]: 'POWERPC',\n      [String(0x01F1)]: 'POWERPCFP',\n      [String(0x0200)]: 'IA64',\n      [String(0x0266)]: 'MIPS16',\n      [String(0x0284)]: 'ALPHA64',\n      [String(0x0366)]: 'MIPSFPU',\n      [String(0x0466)]: 'MIPSFPU16',\n      [String(0x0520)]: 'TRICORE',\n      [String(0x0CEF)]: 'CEF',\n      [String(0x0EBC)]: 'EBC',\n      [String(0x8664)]: 'AMD64',\n      [String(0x9104)]: 'M32R',\n      [String(0xC0EE)]: 'CEE',\n      [String(0x01C4)]: 'ARMNT'\n    }\n    return machines[id] || 'Unknown'\n  }\n\n  /** Decode image type [Magic] */\n  static decodeMagic (id: number): string {\n    let magics = {\n      [String(0x010B)]: 'PE32',\n      [String(0x020B)]: 'PE64',\n      [String(0x0107)]: 'ROM'\n    }\n    return magics[id] || 'Unknown'\n  }\n\n  /** Decode OS version by major and minor [MajorOperatingSystemVersion, MinorOperatingSystemVersion] */\n  static decodeOSVersion (maj: number, min: number) {\n    let version = maj + '.' + min\n    let versions = {\n      '1.1': 'Windows 1.0',\n      '1.2': 'Windows 1.02',\n      '1.3': 'Windows 1.03',\n      '1.4': 'Windows 1.04',\n      '2.3': 'Windows 2.03',\n      '2.10': 'Windows 2.10',\n      '2.11': 'Windows 2.11',\n      '3.0': 'Windows 3.0',\n      '3.10': 'Windows 3.1',\n      '3.11': 'Windows 3.11',\n      '3.2': 'Windows 3.2',\n      '3.50': 'Windows 3.5',\n      '3.51': 'Windows 3.51',\n      '4.0': 'Windows 95',\n      '4.10': 'Windows 98',\n      '5.0': 'Windows 2000',\n      '4.90': 'Windows ME',\n      '5.1': 'Windows XP',\n      '5.2': 'Windows XP Professional x64 Edition',\n      '6.0': 'Windows Vista',\n      '6.1': 'Windows 7',\n      '6.2': 'Windows 8',\n      '6.3': 'Windows 8.1',\n      '10.0': 'Windows 10'\n    }\n    return versions[version] || 'Unknown'\n  }\n\n  /** Decode runtime subsystem [Subsystem] */\n  static decodeSubsystem (id: number): string {\n    let subsystems = {\n      [String(0x0000)]: 'Unknown',\n      [String(0x0001)]: 'Native',\n      [String(0x0002)]: 'WindowsGui',\n      [String(0x0003)]: 'WindowsCui',\n      [String(0x0005)]: 'Os2Cui',\n      [String(0x0007)]: 'PosixCui',\n      [String(0x0008)]: 'NativeWindows',\n      [String(0x0009)]: 'WindowsCeGui',\n      [String(0x000A)]: 'EfiApplication',\n      [String(0x000B)]: 'EfiBootServiceDriver',\n      [String(0x000C)]: 'EfiRuntimeDriver',\n      [String(0x000D)]: 'EfiRom',\n      [String(0x000E)]: 'Xbox',\n      [String(0x0010)]: 'WindowsBootApplication'\n    }\n    return subsystems[id] || 'Unknown'\n  }\n\n  /** Decode characteristics set [Characteristics] */\n  static decodeChars (id: number): Array<string> {\n    let chars = {\n      [String(0x0001)]: 'RelocsStripped',\n      [String(0x0002)]: 'ExecutableImage',\n      [String(0x0004)]: 'LineNumsStripped',\n      [String(0x0008)]: 'LocalSymsStripped',\n      [String(0x0010)]: 'AggressiveWSTrim',\n      [String(0x0020)]: 'LargeAddressAware',\n      [String(0x0040)]: 'Reserved',\n      [String(0x0080)]: 'BytesReversedLo',\n      [String(0x0100)]: '32BitMachine',\n      [String(0x0200)]: 'DebugStripped',\n      [String(0x0400)]: 'RemovableRunFromSwap',\n      [String(0x0800)]: 'NetRunFromSwap',\n      [String(0x1000)]: 'System',\n      [String(0x2000)]: 'DLL',\n      [String(0x4000)]: 'UpSystemOnly',\n      [String(0x8000)]: 'BytesReversedHi'\n    }\n    let charsList: Array<string> = []\n    for (let code in chars) if ((id & +code) === +code) charsList.push(chars[code])\n    return charsList\n  }\n\n  /** Decode library characteristics set [DllCharacteristics] */\n  static decodeDllChars (id: number): Array<string> {\n    let dllchars = {\n      [String(0x0020)]: 'HighEntropyVa',\n      [String(0x0040)]: 'DynamicBase',\n      [String(0x0080)]: 'ForceIntegrity',\n      [String(0x0100)]: 'NxCompat',\n      [String(0x0200)]: 'NoIsolation',\n      [String(0x0400)]: 'NoSeh',\n      [String(0x0800)]: 'NoBind',\n      [String(0x1000)]: 'Appcontainer',\n      [String(0x2000)]: 'WdmDriver',\n      [String(0x4000)]: 'GuardCf',\n      [String(0x8000)]: 'TerminalServerAware'\n    }\n    let dllcharsList = []\n    for (let code in dllchars) if ((id & +code) === +code) dllcharsList.push(dllchars[code])\n    return dllcharsList\n  }\n\n  static decodeSectionsName (sections: Array<SectionHeader>): Array<string> {\n    let names = []\n    sections.forEach(section => {\n      let nonzero = false\n      let name = []\n      section.Name.raw.reverse().forEach(c => {\n        if (c !== 0) nonzero = true\n        if (nonzero) name.push(c)\n      })\n      names.push(String.fromCharCode(...name.reverse()))\n    })\n    return names\n  }\n}\n","export class Type {\r\n  static get Byte() {\r\n    return 1\r\n  }\r\n  static get Word() {\r\n    return Type.Byte * 2\r\n  }\r\n  static get DWord() {\r\n    return Type.Word * 2\r\n  }\r\n  static get QWord() {\r\n    return Type.DWord * 2\r\n  }\r\n  static get YWord() {\r\n    return Type.QWord * 2\r\n  }\r\n  static Array(element: number, count: number) {\r\n    return element * count\r\n  }\r\n  static Data(length: number) {\r\n    return length\r\n  }\r\n}","// @flow\n\nimport type { DataBlock } from '../FileReader'\nimport BlockReader from '../BlockReader'\nimport type { DataBlockDesk } from '../BlockReader'\nimport { Type } from '../types'\n\nexport type DosHeader = {\n  e_magic: DataBlock,\n  e_cblp: DataBlock,\n  e_cp: DataBlock,\n  e_crlc: DataBlock,\n  e_cparhdr: DataBlock,\n  e_minalloc: DataBlock,\n  e_maxalloc: DataBlock,\n  e_ss: DataBlock,\n  e_sp: DataBlock,\n  e_csum: DataBlock,\n  e_ip: DataBlock,\n  e_cs: DataBlock,\n  e_lfarlc: DataBlock,\n  e_ovno: DataBlock,\n  e_res: DataBlock,\n  e_oemid: DataBlock,\n  e_oeminfo: DataBlock,\n  e_res2: DataBlock,\n  e_lfanew: DataBlock,\n}\n\nconst Word = 2\n\nexport default class BlockReaderDosHeader extends BlockReader {\n  read (): DosHeader {\n    let structdef: Array<DataBlockDesk> = [\n      this._desc(Type.Word, 'e_magic', 'Magic number (MZ)'),\n      this._desc(Type.Word, 'e_cblp', 'Bytes on last page of file'),\n      this._desc(Type.Word, 'e_cp', 'Pages in file'),\n      this._desc(Type.Word, 'e_crlc', 'Relocations'),\n      this._desc(Type.Word, 'e_cparhdr', 'Size of header in paragraphs'),\n      this._desc(Type.Word, 'e_minalloc', 'Minimum extra paragraphs needed'),\n      this._desc(Type.Word, 'e_maxalloc', 'Maximum extra paragraphs needed'),\n      this._desc(Type.Word, 'e_ss', 'Initial (relative) SS value'),\n      this._desc(Type.Word, 'e_sp', 'Initial SP value'),\n      this._desc(Type.Word, 'e_csum', 'Checksum'),\n      this._desc(Type.Word, 'e_ip', 'Initial IP value'),\n      this._desc(Type.Word, 'e_cs', 'Initial CS value'),\n      this._desc(Type.Word, 'e_lfarlc', 'File address of relocation table'),\n      this._desc(Type.Word, 'e_ovno', 'Overlay number'),\n      this._desc(Type.Array(Type.Word, 4), 'e_res', 'Reserved'),\n      this._desc(Type.Word, 'e_oemid', 'OEM identifier'),\n      this._desc(Type.Word, 'e_oeminfo', 'OEM information; e_oemid specific'),\n      this._desc(Type.Array(Type.Word, 10), 'e_res2', 'Reserved'),\n      this._desc(Type.Word, 'e_lfanew', 'File address of new exe header')\n    ]\n    let struct = this.readStructure(structdef)\n    return this.convertStructureToMap(struct)\n  }\n}","// @flow\n\nimport type { DataBlock } from '../FileReader'\nimport BlockReader from '../BlockReader'\n\nimport type { DataBlockDesk } from '../BlockReader'\nimport type { DosHeader } from './dosHeader'\n\nexport type FileHeader = {\n  Machine: DataBlock,\n  NumberOfSections: DataBlock,\n  TimeDataStamp: DataBlock,\n  PointerToSymbolTable: DataBlock,\n  NumberOfSymbols: DataBlock,\n  SizeOfOptionalHeader: DataBlock,\n  Characteristics: DataBlock,\n}\n\nconst Word = 2\nconst DWord = 4\n\nexport default class BlockReaderFileHeader extends BlockReader {\n  read (): DosHeader {\n    let structdef: Array<DataBlockDesk> = [\n      this._desc(Word, 'Machine', 'Architecture type of the computer'),\n      this._desc(Word, 'NumberOfSections', 'Size of the section table'),\n      this._desc(DWord, 'TimeDataStamp', 'Date and time the image was created'),\n      this._desc(DWord, 'PointerToSymbolTable', 'Offset of the symbol table, or zero if no COFF symbol table exists'),\n      this._desc(DWord, 'NumberOfSymbols', 'Number of symbols in the symbol table'),\n      this._desc(Word, 'SizeOfOptionalHeader', 'NtOptional32Header'),\n      this._desc(Word, 'Characteristics', 'ExecutableImage, 32BitMachine')\n    ]\n    let struct = this.readStructure(structdef)\n    return this.convertStructureToMap(struct)\n  }\n}","// @flow\n\nimport type { DataBlock } from '../FileReader'\nimport BlockReader from '../BlockReader'\nimport type { DataBlockDesk } from '../BlockReader'\nimport type { ImportDescriptor } from './importDescriptor'\nimport type { ExportDescriptor } from './exportDescriptor'\nimport { Type } from '../types'\n\nexport type DataDirectory = {\n  VirtualAddress: DataBlock,\n  Size: DataBlock,\n}\n\nexport type DataDirectories = {\n  import: Array<ImportDescriptor>,\n  export: Array<ExportDescriptor>,\n}\n\nexport default class BlockReaderDataDirectory extends BlockReader {\n  read (): DataDirectory {\n    let structdef: Array<DataBlockDesk> = [\n      this._desc(Type.DWord, 'VirtualAddress', ''),\n      this._desc(Type.DWord, 'Size', '')\n    ]\n    let struct = this.readStructure(structdef)\n    return this.convertStructureToMap(struct)\n  }\n\n  readAll (): Array<DataDirectory> {\n    let arr = []\n    for (let i = 0; i < 16; i++) {\n      arr.push(this.read())\n    }\n    return arr\n  }\n}","// @flow\n\nimport type { DataBlock } from '../FileReader'\nimport type { DataDirectory } from './dataDirectory'\nimport type { DosHeader } from './dosHeader'\nimport BlockReader from '../BlockReader'\n\nimport type { DataBlockDesk } from '../BlockReader'\nimport BlockReaderDataDirectory from './dataDirectory'\n\nexport type OptionalHeader = {\n  Magic: DataBlock,\n  MajorLinkerVersion: DataBlock,\n  MinorLinkerVersion: DataBlock,\n  SizeOfCode: DataBlock,\n  SizeOfInitializedData: DataBlock,\n  SizeOfUninitializedData: DataBlock,\n  AddressOfEntryPoint: DataBlock,\n  BaseOfCode: DataBlock,\n  BaseOfData: DataBlock,\n  ImageBase: DataBlock,\n  SectionAlignment: DataBlock,\n  FileAlignment: DataBlock,\n  MajorOperatingSystemVersion: DataBlock,\n  MinorOperatingSystemVersion: DataBlock,\n  MajorImageVersion: DataBlock,\n  MinorImageVersion: DataBlock,\n  MajorSubsystemVersion: DataBlock,\n  MinorSubsystemVersion: DataBlock,\n  Win32VersionValue: DataBlock,\n  SizeOfImage: DataBlock,\n  SizeOfHeaders: DataBlock,\n  CheckSum: DataBlock,\n  Subsystem: DataBlock,\n  DllCharacteristics: DataBlock,\n  SizeOfStackReserve: DataBlock,\n  SizeOfStackCommit: DataBlock,\n  SizeOfHeapReserve: DataBlock,\n  SizeOfHeapCommit: DataBlock,\n  LoaderFlags: DataBlock,\n  NumberOfRvaAndSizes: DataBlock,\n  DataDirectory: Array<DataDirectory>,\n}\n\nconst Byte = 1\nconst Word = 2\nconst DWord = 4\n\nexport default class BlockReaderOptionalHeader extends BlockReader {\n  read (): DosHeader {\n    let structdef: Array<DataBlockDesk> = [\n      this._desc(Word, 'Magic', 'PE32 - State of the image file'),\n      this._desc(Byte, 'MajorLinkerVersion', ''),\n      this._desc(Byte, 'MinorLinkerVersion', ''),\n      this._desc(DWord, 'SizeOfCode', 'Size of the code section'),\n      this._desc(DWord, 'SizeOfInitializedData', 'Size of the initialized data section'),\n      this._desc(DWord, 'SizeOfUninitializedData', 'Size of the uninitialized data section'),\n      this._desc(DWord, 'AddressOfEntryPoint', 'Pointer to the entry point function, relative to the image base address, or zero if no entry point is present'),\n      this._desc(DWord, 'BaseOfCode', 'Pointer to the beginning of the code section, relative to the image base'),\n      this._desc(DWord, 'BaseOfData', 'Pointer to the beginning of the data section, relative to the image base'),\n      this._desc(DWord, 'ImageBase', 'Preferred address of the first byte of the image when it is loaded in memory'),\n      this._desc(DWord, 'SectionAlignment', 'Alignment of the section loaded in memory'),\n      this._desc(DWord, 'FileAlignment', 'Alignment of the raw data of sections in the image file'),\n      this._desc(Word, 'MajorOperatingSystemVersion', 'Major version number of the required operating system'),\n      this._desc(Word, 'MinorOperatingSystemVersion', 'Minor version number of the required operating system'),\n      this._desc(Word, 'MajorImageVersion', ''),\n      this._desc(Word, 'MinorImageVersion', ''),\n      this._desc(Word, 'MajorSubsystemVersion', ''),\n      this._desc(Word, 'MinorSubsystemVersion', ''),\n      this._desc(DWord, 'Win32VersionValue', 'Reserved'),\n      this._desc(DWord, 'SizeOfImage', 'Size of the image including all headers'),\n      this._desc(DWord, 'SizeOfHeaders', ''),\n      this._desc(DWord, 'CheckSum', 'Image file checksum'),\n      this._desc(Word, 'Subsystem', 'WindowsCui - Subsystem required to run this image'),\n      this._desc(Word, 'DllCharacteristics', 'DynamicBase, NxCompat, TerminalServerAware - DLL characteristics of the image'),\n      this._desc(DWord, 'SizeOfStackReserve', 'Number of bytes to reserve for the stack'),\n      this._desc(DWord, 'SizeOfStackCommit', 'Number of bytes to commit for the stack'),\n      this._desc(DWord, 'SizeOfHeapReserve', 'Number of bytes to reserve for the local heap'),\n      this._desc(DWord, 'SizeOfHeapCommit', 'Number of bytes to commit for the local heap'),\n      this._desc(DWord, 'LoaderFlags', 'Obsolete'),\n      this._desc(DWord, 'NumberOfRvaAndSizes', 'Number of directory entries in the remainder of the optional header')\n    ]\n    let struct = this.readStructure(structdef)\n    let map: Object = this.convertStructureToMap(struct)\n\n    let brDataDirectories = new BlockReaderDataDirectory()\n    brDataDirectories.setReader(this._reader)\n\n    map.DataDirectory = brDataDirectories.readAll()\n\n    return map\n  }\n}","// @flow\n\nimport type { DataBlock } from '../FileReader'\nimport type { FileHeader } from './fileHeader'\nimport type { OptionalHeader } from './optionalHeader'\nimport type { DosHeader } from './dosHeader'\nimport BlockReader from '../BlockReader'\n\nimport type { DataBlockDesk } from '../BlockReader'\nimport BlockReaderFileHeader from './fileHeader'\nimport BlockReaderOptionalHeader from './optionalHeader'\n\nexport type NtHeader = {\n  Signature: DataBlock,\n  file: FileHeader,\n  optional: OptionalHeader\n}\n\nconst DWord = 4\n\nexport default class BlockReaderNTHeader extends BlockReader {\n  read (): NtHeader {\n    let structdef: Array<DataBlockDesk> = [\n      this._desc(DWord, 'Signature', 'PE\\\\0\\\\0')\n    ]\n    let struct = this.readStructure(structdef)\n    let map: Object = this.convertStructureToMap(struct)\n\n    let brFileHeader = new BlockReaderFileHeader()\n    brFileHeader.setReader(this._reader)\n\n    let brOptionalHeader = new BlockReaderOptionalHeader()\n    brOptionalHeader.setReader(this._reader)\n\n    map.file = brFileHeader.read()\n    map.optional = brOptionalHeader.read()\n\n    return map\n  }\n}","// @flow\n\nimport type { DataBlock } from '../FileReader'\nimport BlockReader from '../BlockReader'\nimport type { DataBlockDesk } from '../BlockReader'\n\nexport type SectionHeader = {\n  Name: DataBlock,\n  VirtualSize: DataBlock,\n  VirtualAddress: DataBlock,\n  SizeOfRawData: DataBlock,\n  PointerToRawData: DataBlock,\n  PointerToRelocations: DataBlock,\n  PointerToLinenumbers: DataBlock,\n  NumberOfRelocations: DataBlock,\n  NumberOfLinenumbers: DataBlock,\n  Characteristics: DataBlock,\n}\n\nconst Byte = 1\nconst Word = 2\nconst DWord = 4\n\nexport default class BlockReaderSectionHeader extends BlockReader {\n  read (): SectionHeader {\n    let structdef: Array<DataBlockDesk> = [\n      this._desc(Byte * 8, 'Name', ''),\n      this._desc(DWord, 'VirtualSize', ''),\n      this._desc(DWord, 'VirtualAddress', ''),\n      this._desc(DWord, 'SizeOfRawData', ''),\n      this._desc(DWord, 'PointerToRawData', ''),\n      this._desc(DWord, 'PointerToRelocations', ''),\n      this._desc(DWord, 'PointerToLinenumbers', ''),\n      this._desc(Word, 'NumberOfRelocations', ''),\n      this._desc(Word, 'NumberOfLinenumbers', ''),\n      this._desc(DWord, 'Characteristics', '')\n    ]\n    let struct = this.readStructure(structdef)\n    return this.convertStructureToMap(struct)\n  }\n\n  readAll (count: number): Array<SectionHeader> {\n    let arr = []\n    for (let i = 0; i < count; i++) arr.push(this.read())\n    return arr\n  }\n}","// @flow\n\nimport type { DataBlock } from '../FileReader'\nimport BlockReader from '../BlockReader'\nimport type { DataBlockDesk } from '../BlockReader'\n\nexport type ImportDescriptor = {\n  OriginalFirstThunk: DataBlock,\n  TimeDateStamp: DataBlock,\n  ForwarderChain: DataBlock,\n  Name: DataBlock,\n  FirstThunk: DataBlock,\n}\n\nconst DWord = 4\n\nexport default class BlockReaderImportDescriptor extends BlockReader {\n  read (): ImportDescriptor {\n    let structdef: Array<DataBlockDesk> = [\n      this._desc(DWord, 'OriginalFirstThunk', ''),\n      this._desc(DWord, 'TimeDateStamp', ''),\n      this._desc(DWord, 'ForwarderChain', ''),\n      this._desc(DWord, 'Name', ''),\n      this._desc(DWord, 'FirstThunk', ''),\n    ]\n    let struct = this.readStructure(structdef)\n    return this.convertStructureToMap(struct)\n  }\n\n  readAll (): Array<ImportDescriptor> {\n    let arr = []\n    for (;;) {\n      let desc = this.read()\n      if (desc.OriginalFirstThunk.num === 0) break\n      arr.push(desc)\n    }\n    return arr\n  }\n}","// @flow\n\nimport type { DataBlock } from '../FileReader'\nimport BlockReader from '../BlockReader'\nimport type { DataBlockDesk } from '../BlockReader'\nimport { Type } from '../types'\n\nexport type ExportDescriptor = {\n  Characteristics: DataBlock,\n  TimeDateStamp: DataBlock,\n  MajorVersion: DataBlock,\n  MinorVersion: DataBlock,\n  Name: DataBlock,\n  Base: DataBlock,\n  NumberOfFunctions: DataBlock,\n  NumberOfNames: DataBlock,\n  AddressOfFunctions: DataBlock,\n  AddressOfNames: DataBlock,\n  AddressOfNameOrdinals: DataBlock,\n}\n\nconst Word = 2\nconst DWord = 4\n\nexport default class BlockReaderExportDescriptor extends BlockReader {\n  read (): ExportDescriptor {\n    let structdef: Array<DataBlockDesk> = [\n      this._desc(Type.DWord, 'Characteristics', ''),\n      this._desc(Type.DWord, 'TimeDateStamp', ''),\n      this._desc(Type.Word, 'MajorVersion', ''),\n      this._desc(Type.Word, 'MinorVersion', ''),\n      this._desc(Type.DWord, 'Name', ''),\n      this._desc(Type.DWord, 'Base', ''),\n      this._desc(Type.DWord, 'NumberOfFunctions', ''),\n      this._desc(Type.DWord, 'NumberOfNames', ''),\n      this._desc(Type.DWord, 'AddressOfFunctions', ''),\n      this._desc(Type.DWord, 'AddressOfNames', ''),\n      this._desc(Type.DWord, 'AddressOfNameOrdinals', ''),\n    ]\n    let struct = this.readStructure(structdef)\n    return this.convertStructureToMap(struct)\n  }\n\n  readAll (): Array<ExportDescriptor> {\n    let arr = []\n    for (;;) {\n      let desc = this.read()\n      if (desc.Name.num === 0) break\n      arr.push(desc)\n    }\n    return arr\n  }\n}","// @flow\n/*\n  Парсер исполняемых файлов\n*/\n\nimport FileReader from './libs/FileReader'\nimport BlockReader from './libs/BlockReader'\nimport DataDictionary from './libs/DataDictionary'\n\nimport type { ExeFile } from './libs/ExeFile/struct'\nimport type { SectionHeader } from './libs/ExeFile/sectionHeader'\nimport type { Meta } from './libs/ExeFile/meta'\nimport BlockReaderDosHeader from './libs/ExeFile/dosHeader'\nimport BlockReaderNTHeader from './libs/ExeFile/ntHeader'\nimport type { DosHeader } from './libs/ExeFile/dosHeader'\nimport type { NtHeader } from './libs/ExeFile/ntHeader'\nimport BlockReaderSectionHeader from './libs/ExeFile/sectionHeader'\nimport type { ImportDescriptor } from './libs/ExeFile/importDescriptor'\nimport BlockReaderImportDescriptor from './libs/ExeFile/importDescriptor'\nimport type { ExportDescriptor } from './libs/ExeFile/exportDescriptor'\nimport BlockReaderExportDescriptor from './libs/ExeFile/exportDescriptor'\n\nexport default class Pexe {\n  breader: BlockReader\n\n  constructor (bytes?: Uint8Array) {\n    if (bytes) this.setFile(bytes)\n  }\n\n  /**\n   * Устанавливает байты целевого файла\n   * @param bytes {Uint8Array}\n   */\n  setFile (bytes: Uint8Array) {\n    this.breader = new BlockReader(new FileReader(bytes))\n  }\n\n  /**\n   * Извлекает файл из сети и устанавливает его в качестве целевого\n   * @param url\n   * @returns {Promise<void>}\n   */\n  async fetchFile (url: string) {\n    let resp = await window.fetch(url)\n    let buff = await resp.arrayBuffer()\n    this.setFile(new Uint8Array(buff))\n  }\n\n  /*\n  RAW (file offset) = RVA - sectionRVA + rawSection // Смещение относительно начала файла\n  RVA (Relative Virtual Address) =  // Адрес относительно того, куда была выгружена программа\n  VA (Virtual Address) = ImageBase + RVA // Адрес относительно начала виртуальной памяти\n\n  rawSection - смещение до секции от начала файла\n  sectionRVA - RVA секции (это поле хранится внутри секции)\n   */\n\n  /**\n   * Генерирует функцию конвертации RVA в RAW адреса\n   * @param sections\n   * @param alignment\n   * @returns {Function}\n   */\n  generateRvaToRawFunc (sections: Array<SectionHeader>, alignment: number): (rva: number) => number | null {\n    let alignUp = (n, a) => Math.ceil(n / a) * a\n    return (rva: number): number | null => {\n      for (let i = 0; i < sections.length; i++) {\n        let start = sections[i].VirtualAddress.num\n        let end = start + alignUp(sections[i].VirtualSize.num, alignment)\n        if (rva >= start && rva < end) {\n          return rva - sections[i].VirtualAddress.num + sections[i].PointerToRawData.num\n        }\n      }\n      return null\n    }\n  }\n\n  /**\n   * Формирует мета-информацию принимая готовую распаршенную информацию\n   * По сути не добавляет никакой новой информации, но приводит в читаемый вид существующую\n   * @param exe {ExeFile}\n   * @returns {Meta}\n   */\n  getMeta (exe: ExeFile): Meta {\n    let meta: Meta = {}\n    meta.isDOS = exe.headers.dos.e_magic.text === 'MZ'\n    meta.isNT = exe.headers.nt.Signature.text === 'PE\\0\\0'\n\n    if (meta.isNT) {\n      meta.machine = DataDictionary.decodeMachine(exe.headers.nt.file.Machine.num)\n      meta.magic = DataDictionary.decodeMagic(exe.headers.nt.optional.Magic.num)\n      meta.subsystem = DataDictionary.decodeSubsystem(exe.headers.nt.optional.Subsystem.num)\n      meta.chars = DataDictionary.decodeChars(exe.headers.nt.file.Characteristics.num)\n      meta.dllChars = DataDictionary.decodeDllChars(exe.headers.nt.optional.DllCharacteristics.num)\n      meta.sections = DataDictionary.decodeSectionsName(exe.sections)\n\n      meta.osVersion = DataDictionary.decodeOSVersion(\n        exe.headers.nt.optional.MajorOperatingSystemVersion.num,\n        exe.headers.nt.optional.MinorOperatingSystemVersion.num\n      )\n\n      meta.dateStamp = new Date(exe.headers.nt.file.TimeDataStamp.num * 1000)\n\n      meta.isDLL = meta.chars.includes('DLL')\n      meta.is64 = meta.magic === 'PE64'\n\n      // isTrunked\n      // isNET\n      // isDebug\n    }\n    return meta\n  }\n\n  /**\n   * Читает DOS заголовок\n   * @returns {DosHeader}\n   */\n  readDOSHeader (): DosHeader {\n    let brDOSReader = new BlockReaderDosHeader()\n    brDOSReader.setReader(this.breader.getReader())\n    return brDOSReader.read()\n  }\n\n  /**\n   * Читает NT заголовок\n   * @returns {NtHeader}\n   */\n  readNTHeader (): NtHeader {\n    let brNTHeader = new BlockReaderNTHeader()\n    brNTHeader.setReader(this.breader.getReader())\n    return brNTHeader.read()\n  }\n\n  /**\n   * Читает секции\n   * @param count\n   * @returns {Array<SectionHeader>}\n   */\n  readSections (count: number): Array<SectionHeader> {\n    let brSection = new BlockReaderSectionHeader()\n    brSection.setReader(this.breader.getReader())\n    return brSection.readAll(count)\n  }\n\n  /**\n   * Читает таблицу импортов\n   * @returns {Array<ImportDescriptor>}\n   */\n  readDirImportDescriptors (): Array<ImportDescriptor> {\n    let brImportDesc = new BlockReaderImportDescriptor()\n    brImportDesc.setReader(this.breader.getReader())\n    return brImportDesc.readAll()\n  }\n\n  /**\n   * Читает таблицу экспортов\n   * @returns {Array<ExportDescriptor>}\n   */\n  readDirExportDescriptors (): Array<ExportDescriptor> {\n    let brExportDesc = new BlockReaderExportDescriptor()\n    brExportDesc.setReader(this.breader.getReader())\n    return brExportDesc.readAll()\n  }\n\n  /**\n   * Возвращает информацию по исполняемому файлу\n   * @returns {ExeFile}\n   */\n  parse (): ExeFile {\n    let file: Object = {\n      bytes: this.breader.getFileBytes(),\n      meta: {},\n      headers: {\n        dos: {},\n        nt: {}\n      },\n      sections: [],\n      directories: {},\n    }\n    let exe: ExeFile = file\n\n    exe.headers.dos = this.readDOSHeader()\n\n    // Если DOS приложение\n    if (exe.headers.dos.e_magic.text === 'MZ') {\n      this.breader.setPointer(exe.headers.dos.e_lfanew.num)\n      exe.headers.nt = this.readNTHeader()\n\n      // Если Windows приложение\n      if (exe.headers.nt.Signature.text === 'PE\\0\\0') {\n        exe.sections = this.readSections(exe.headers.nt.file.NumberOfSections.num)\n\n        let rvaToRaw = this.generateRvaToRawFunc(exe.sections, exe.headers.nt.optional.SectionAlignment.num)\n\n        // Чтение таблицы импорта\n        let rawImportDir = rvaToRaw(exe.headers.nt.optional.DataDirectory[1].VirtualAddress.num)\n        if (rawImportDir) {\n          this.breader.setPointer(rawImportDir)\n          exe.directories.import = this.readDirImportDescriptors()\n        }\n\n        let rawExportDir = rvaToRaw(exe.headers.nt.optional.DataDirectory[0].VirtualAddress.num)\n        if (rawExportDir) {\n          this.breader.setPointer(rawExportDir)\n          exe.directories.export = this.readDirExportDescriptors()\n        }\n\n      }\n\n    }\n\n    exe.meta = this.getMeta(exe)\n\n    return exe\n  }\n}\n"],"sourceRoot":""}